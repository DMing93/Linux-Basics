# c语言简要语法手册(C brief handbook)

起草人: 赵益民 王聚生

## 前言
> 本章内容基本整理自"c和指针(pointers on c)"这一本书,内容顺序基本按照书中顺序. 本文的初衷是总结c语言中易混淆,难记忆需要反复查手册的内容,方便起见整理在一起,并**没有**包含所有的语法点,

## 目录
- 一. 标识符
  - 1.1 extern & static 链接属性
  - 1.2 static用于代码块内部的变量声明
  - 1.3 typedef
  - 1.4 const 常量定义
  - 1.5 auto & register 存储类型
  - 1.6 volatile
- 二. 循环体
  - 2.1 循环语句
  - 2.2 循环控制
  - 2.3 break和goto语句
- 三. 数组
  - 3.1 数组名和指针
  - 3.2 下标引用
  - 3.3 作为函数参数的数组名
  - 3.4 二维数组
  - 3.5 指针数组与数组指针
- 四. 结构体
  - 4.1 结构成员
  - 4.2 结构体声明
  - 4.3 结构体的自引用
  - 4.4 不完整的声明
  - 4.5 结构体的初始化
- 五. 字符串操作
  - 5.1 相关函数介绍
- 六. 动态内存分配
  - 6.1 使用动态内存分配
- 选择题

<br/>
<br/>

# 一. 标识符
```c 
//类型修饰符 ( type specifier )
auto static register    // 存储类型修饰符
extern static           // 链接属性修饰符
signed unsigned         // 符号类型修饰符
volatile const          // 特殊功能修饰符
//其他类型
short int char long double float void // 一般内置类型
struct union enum // 高级类型
if else switch case default while for continue break do goto return//条件控制
sizeof  typedef    
```

> static在不同的上下文中有不同的意思,以下是用于函数定义时,或者代码块之外的变量声明时的含义

<br/>

## 1.1 extern & static 链接属性
当组成一个程序的各个源文件分别编译之后,所有的目标文件以及那些从一个或者多个函数库中引用的函数链接在一起,形成可执行程序.然而,如果相同的变量名称出现在几个不同的源文件中,他们是表示同一个实体还是不同实体?标识符的**链接属性**(linkage)决定如何处理在不同文件中出现的标识符.

链接属性一共有3中--external(外部),internal(内部)和none(无).没有链接属性的标识符(none)总是被当做单独的个体.属于internal链接属性的标识符在同一个源文件内的所有声明中都指向一个实体,但是位于不同源文件中的多个声明则分属不同的实体.最后,属性external链接属性的标识符不论声明几次,位于几个源文件中都表示同一个实体.

下面代码中,在缺省情况下,b,c,f的链接属性是external,其余为none
```c
    typedef char *a;
    int b;
    int c(int d)
    {
        int e;
        int f(int g);
        ...
    }
```
关键字extern和static用于在声明中修改标识符的链接属性. 如果某个声明在正常情况下是external属性,在前面加上static可以把他的链接属性变成internal, 例如修改上面第二个声明:
```c
static int b;
```
那么变量b将为这个源文件所私有. static只对缺省链接属性为external的声明才有改变链接属性的效果.

如果如一个变量进行两次不一致的声明, 那么声明的链接属性以第一次为准.


<br/>


## 1.2 static用于代码块内部的变量声明
当static用于代码块内部的变量声明是,static关键字用于修改变量的存储类型, 从自动变量修改为静态变量, 但变量的链接属性和作用域不受影响. 这样创建的变量在程序执行前创建, 并在程序的整个执行期间一直存在, 而不是每次在代码块开始执行时创建, 在代码执行完后就销毁.

<br/>

## 1.3 typedef
c语言支持一种typedef的机制,它允许你为各种数据类型定义新的名字.typedef声明的写法和普通的声明基本相同,只是把typedef这个关键字出现在声明的前面,例如下面的这个声明:
    
```c
typedef char *ptr_to_char;
```

这个声明把标识符ptr_to_char作为指向字符的指针型的新名字.你可以像使用任何预定义名字一样在下面声明中使用这个新名字

```c
ptr_to_char  a;
```

## 1.4 const 常量定义
ANSI C允许你声明常量, 常量的样子和变量完全一致, 只是他们的值不能修改. 使用const关键字来声明常量:
```c
    int const a;
    const int b;
```
两句话含义相同, 选择自己容易理解的一种并且检查使用同一种形式. 

由于声明的变量是常量, 你只能在声明时对它进行初始化, 其他时间无法修改它的值:
```c
    int const a = 15;
```
当涉及到指针时, 情况就变得更加有趣, 看下面几个声明的例子:
```c
    int                 *pi;    //pi是一个普通的指向整型的指针
    int const           *pci;   //pci是一个指向整型常量的指针, 你可以修改指针, 不能修改它指向的值
    int * const         *cpi;   //cpi同上面相反, 你不能修改指针的值
    int const * const   cpci;   //这样, 两者都不能修改了
```

## 1.5 auto & register 存储类型
变量的存储类型(storage class)是指存储变量值的内存类型, 变量的存储类型决定变量何时创建, 销毁以及他的值将保持多久. 有三个地方可以用于存储变量: 普通内存, 运行时堆栈, 硬件寄存器.

凡是在任何代码块之外声明的变量总是存储在静态内存中, 也就是不属于堆栈的内存, 这类变量称为静态(static)变量, 在代码块内使用static关键字声明.

而在代码块内部声明的变量, 缺省的存储类型是自动的(automatic), 它存储在堆栈中. auto用于声明这种情况, 但是由于auto是缺省的, 实际中极少使用.

最后, 关键字register用于自动变量的声明, 提示他们应该存储在机器的硬件寄存器中, 而不是内存中, 这类变量被称为寄存器变量. 寄存器变量比其他存储在内存中的变量访问起来效率高, 但是寄存器数量是有限的, 编译器只会选取前几个声明的变量实际存储在寄存器中, 其他的按普通自动变量. 

## 1.6 volatile
在更微观的层面上, 同样的变量在两条相邻的语句都可能是不同的值,考虑多线程的情况,不同线程读取同一个值,CPU调度使得我们无法确定他们在什么时机发生. 而恰恰编译器在编译源代码的时候, 会对源代码进行一定的优化, 例如常量合并, 代码合并等操作.
```c
    if(value){      //优化前
        printf("true\n");
    }else {
        printf("false\n");
    }
    if(value) {
        printf("true\n");
    }else {
        printf("false\n");
    }

    if(value){      //优化后
        printf("true\n");
        printf("true\n");
    }else{
        printf("false\n");
        printf("false\n");
    }
``` 

valatile关键字告诉编译器, 防止它以一种可以修改程序含义的方式优化程序. 使得系统总是从它所在的内存读取数据, 即使它前面的指令刚刚从该处读取过数据. 如果不加入volatile，基本上会导致这样的结果：要么无法编写多线程程序, 要么编译器失去大量优化的机会。
<hr/>
<br/>
<br/>

# 二. 循环体
## 2.1 循环语句
c语言有三种基本循环语句,for()语句，while()语句和do...while()语句。
### for()循环
```c
   for(e1;e2;e3)  //e1:变量初始化区，只执行一次。e2:循环控制区，每次都要先检查e2表达式的结果是否为真，为真进入循环，否则循环结束。e3:循环变量变化区，每次执行完for_statements;转到这里，执行e3，然后转到e2
   {
        for_statements ;     
   }   //多条语句需用{} 括起来，单条语句可以不用，但建议使用：1.代码清楚，2.便于差错。其他循环也是这样
  
    /*执行顺序：e1->e2(判断为真)->for_statements->e3->e2(判断)
               ....e2(判断为假)->跳出循环
    */
```
### while()循环
```c
    while(e)  //e为循控制条件，e为真进入循环，否则跳出循环。
    {
        while_statements ;  // e为真执行。执行完调到 e 处。
    }
    /*while_statements; 包含循环控制变量*/
```
###  do...while()循环
```c
    do{
        do_while_statements;
    }while(e); //尾部有分号,e为循环控制条件
    /*与while()不同的是，这里可以没有循环变量的初始化，先进行循环语句的操作，然后，再判断是否继续进行，所以，这种循环，至少要执行一do_while_statements; 而前两种，有可能一次都不执行循环语句*/
```
## 2.2 循环控制
### break语句
break语句通常用在循环语句和开关语句中。当break用于开关语句switch中时，可使程序跳出switch而执行switch以后的语句；如果没有break语句，则将成为一个死循而无法退出。当break语句用于do-while、for、while循环语句中时，可使程序终止循而执行循环后面的语句，通常break语句总是与if语句联在一起。即满足条件时便跳出循环。
```c
    main()
    {   
        int sn=0,i;  
        for(i=1;i<=100;i++) 
        {  
            if(i==51) break; /*如果i等于51，则跳出循环*/ 
            sn+=i; /*1+2+……+50*/ 
        }  
        printf(%d\n,sn);    
     }
     /*可以看出，最终的结果是1+2+……+50。因为在i等于51的时候，就跳出循环了。*/
     /*break语句对if-else的条件语句不起作用。在多层循环中，一个break语句只向外跳一层。*/
```
### continue语句
continue语句的作用是跳过循环本中剩余的语句而强行执行下一次循环。continue语句只用在for、while、do-while等循环体中, 常与if条件语句一起使用，用来加速循环。
```c
    main()  
    {  
        int i,j;  
        for(i=0;i<2;i++) 
            for(j=0;j<3;j++) 
            {  
                if(j==1) continue; 
                printf(%d %d\n,i,j); 
            } 
            
    }   
    /*输出结果为:  i j 
    *            0 0 
    *            0 2 
    *            1 0 
    *            1 2
    * 从程序中可以看出，continue语句只是当前的值没有执行，也就是说当前的值跳过去了，接着执行下次循环。
    */
```
### goto语句
goto语句是一种无条件转移语句。
goto语句的使用格式为:  
goto 标号;
```c
    main()
    {   
        int sn=0,i;  
        for(i=1;i<=100;i++) 
        {  
            if(i==51) goto loop; /*如果i等于51，则跳出循环*/ 
            sn+=i; /*1+2+……+50*/ 
        }  
loop:   
        printf(%d\n,sn); 
    } 
    /*可以看出，这儿的goto语句和break作用很类似。 这儿的loop:  printf(%d\n,sn);  也可以写成loop: printf(%d\n,sn); */
    /*标号要一起出现在函数内某处，执行goto语句后，程序将跳转到该标号处并执行其后的语句。标号既然是一个标识符，也就要满足标识符的命名规则。另外标号必须与goto语句同处于一个函数中，但可以不在一个循环层中。通常goto语句与if条件语句连用，当满足某一条件时，程序跳到标号处运行。goto语句通常不用，主要因为它将使程序层次不清，且不易读*/
```
## 2.3 break和goto语句
goto语句是一种危险的语句, 因为在学习C的过程中, 很容易形成对它的依赖. 经验欠缺的程序员有时使用goto语句来避免考虑程序的设计. 但是, 在一种情况下, 即时是结构良好的程序, 使用goto语句也可能非常适合--就是跳出多层嵌套的循环. 由于**break语句只影响包围它的最外层循环**, 要想从深层嵌套的循环中退出只有使用一个办法,就是使用goto语句.
```c
    while( condition1 ){
        while( condition2 ){
            while( condition3 ){
                if( some disaster )
                    goto quit;
            }
        }
    }
quit:   ;
```
要想在这种情况下避免使用goto语句有两种方案. 第一种方案是当你希望退出所有循环时设置一个状态标志, 但这个标志在每个循环中都必须进行测试
```c
    enum{ EXIT, OK } status;
    ...
    status = OK;
    while( status == OK && condition1){
        while (status == OK && condition2 ){
            while(condition3){
                if( some disaster){
                    status = EXIT;
                    break;
                }
            }
        }
    }
```
这个技巧能够实现退出所有循环的目的, 但是情况被弄得非常复杂. 另一种方案是把所有的循环都放到一个单独的函数里, 当灾难降临到最内层的循环时, 你可以使用return语句离开这个函数.
<hr/>
<br/>
<br/>

# 三. 数组
## 3.1 数组名和指针
在C中, 在几乎所有使用数组名的表达式中, 数组名的值是一个指针**常量**, 也就是数组第一个元素的地址. 它的类型取决与数组元素的类型: 如果它是int类型, 那么数组名的类型就是"指向int的**常量**指针"; 如果他们是其他类型, 那么数组名的类型就是"指向其他类型的**常量**指针".
注意这个值是指针常量, 而不是指针变量, 意味着运行时你不能修改它的值.
看下面这个例子:
```c
    int a[10];
    int b[10];
    int *c;
    ...
    c = &a[0];
```
最后一条赋值同下面是等价的:
```c
    c = a;
```
根据上面的结论, 下面这条赋值是违法的:
```c
    a = c;
```


## 3.2 下标引用
C的下标值总是从零开始, 并且不会对下标值进行有效性检查. 除了优先级不同外(下标引用的优先级高于间接访问), 下标引用操作和间接访问表达式是等价的. 他们的映像关系:
```c
    array[index];
    *(array + (index))
```

## 3.3 作为函数参数的数组名
当一个数组名作为参数传递给一个函数时,此时传递给函数的是一份该指针的拷贝.如果你想声明一个函数接受数组作为参数, 它应该声明为一个指针还是数组? 实际上编译器接受两种形式的声明, 下面两个函数原型是相等的:
```c
    int strlen(char *string);
    int strlen(char string[]);
```
下面考虑这个问题
```c
    int a[] = {1, 2, 3, 4, 5};
    int length;
    length = sizeof(a)  // length??
    void func(int *arr){
        int length;
        length = sizeof(arr) // length??
    }
```
两次length的值分别是多少?

第一个length是20(5*4), 它是数组的长度, 而第二个length是8, 它仅仅是指针的长度.

## 3.4 二维数组
一维数组只有一个下标，称为一维数组，其数组元素也称为单下标变量。在实际问题中有很多量是二维的或多维的，因此C语言允许构造多维数组。**多维数组元素有多个下标，以标识它在数组中的位置，所以也称为多下标变量**。本节只介绍二维数组，多维数组可由二维数组类推而得到。
### 3.4.1二维数组的定义
二维数组定义的一般形式是：

    类型说明符 数组名[常量表达式1][常量表达式2]
其中常量表达式1表示第一维下标的长度，常量表达式2 表示第二维下标的长度。
```c
    int a[2][3]
```
说明了一个两行三列的数组，数组名为a，其下标变量的类型为整型。该数组的下标变量共有2×3个，即：

    a[0][0], a[0][1], a[0][2]
    a[1][0], a[1][1], a[1][2]

二维数组在概念上是二维的，即是说其下标在两个方向上变化，下标变量在数组中的位置也处于一个平面之中，而不是象一维数组只是一个向量。但是，实际的硬件存储器却是连续编址的，也就是说存储器单元是按一维线性排列的。如何在一维存储器中存放二维数组，可有两种方式：一种是按行排列， 即放完一行之后顺次放入第二行。另一种是按列排列， 即放完一列之后再顺次放入第二列。

### 3.4.2 二维数组的初始化
二维数组初始化也是在类型说明时给各下标变量赋以初值。二维数组可按行分段赋值，也可按行连续赋值。

例如对数组 a[5][3]：

按行分段赋值可写为：
    
    int a[5][3]={ {80,75,92}, {61,65,71}, {59,63,70}, {85,87,90}, {76,77,85} };
按行连续赋值可写为：
    
    int a[5][3]={ 80,75,92,61,65,71,59,63,70,85,87,90,76,77,85};
这两种赋初值的结果是完全相同的。

    说明;
    1) 可以只对部分元素赋初值，未赋初值的元素自动取0值。例如：
    int a[3][3]={{1},{2},{3}};
    是对每一行的第一列元素赋值，未赋值的元素取0值。 赋值后各元素的值为：
             1  0  0
             2  0  0
             3  0  0
    int a [3][3]={{0,1},{0,0,2},{3}};
    赋值后的元素值为：
             0  1  0
             0  0  2
             3  0  0

    2) 如对全部元素赋初值，则第一维的长度可以不给出。例如：
    int a[3][3]={1,2,3,4,5,6,7,8,9};
    可以写为：
    int a[][3]={1,2,3,4,5,6,7,8,9};

    3) 数组是一种构造类型的数据。二维数组可以看作是由一维数组的嵌套而构成的。设一维数组的每个元素都又是一个数组，就组成了二维数组。当然，前提是各元素类型必须相同。根据这样的分析，一个二维数组也可以分解为多个一维数组。C语言允许这种分解。

    如二维数组a[3][4]，可分解为三个一维数组，其数组名分别为：
            a[0]
            a[1]
            a[2]
    对这三个一维数组不需另作说明即可使用。这三个一维数组都有4个元素，例如：一维数组a[0]的元素为a[0][0],a[0][1],a[0][2],a[0][3]。必须强调的是，a[0],a[1],a[2]不能当作下标变量使用，它们是数组名，不是一个单纯的下标变量。
    
## 3.5 指针数组与数组指针
**指针数组**：*array of pointers*，即用于存储指针的数组，也就是数组元素都是指针

**数组指针**：*a pointer to an array*，即指向数组的指针

    还要注意的是他们用法的区别：

    int* a[4]     指针数组     
    
                 表示：数组a中的元素都为int型指针    

                 元素表示：*a[i]   *(a[i])是一样的，因为[]优先级高于*

    int (*a)[4]   数组指针     

                 表示：指向数组a的指针

                 元素表示：(*a)[i] 
    注意：在实际应用中，对于指针数组，我们经常这样使用：
            typedef int* pInt;
            pInt a[4];
<hr/>
<br/>
<br/>


# 四. 结构体
## 4.1 结构成员
.和->操作符用于访问一个结构的成员. 如果是一个结构变量, 那么s.a就是访问s中名叫a的成员. 当你拥有一个指向结构的指针而不是结构本身, 且欲访问它的成员时, 就需要使用->操作符而不是'.'

## 4.2 结构体声明
区别以下代码：
```c 
    struct {
        int     a;
        char    b;
        float   c;
    } y[20], *z;

    typedef struct {
        int     a;
        char    b;
        float   c;
    } Simple;
```
第一段声明创建了y和z。y是一个数组，它包含了20个结构，z是一个指针，它指向了这个类型的结构。

第二段它使用了typedef创建了一种新的类型，现在的Simple是一个类型名而不是结构标签，所以后续的声明可能像下面这个样子：
```c 
    Simple  x;
    Simple  y[20], *z;
```

## 4.3 结构体的自引用
如何在一个结构体内部包含一个类型为该结构本身的成员？
```c
    struct SELF_REF1{
        int     a;
        struct SELF_REF1 b;
        int     c;
    }
```
上面这个自引用是非法的，因为b是另一个完整的结构体，其内部还将包含自己的成员b，这样重复下去永无止境。而下面的示例是合法的：
```c 
    struct SELF_REF2{
        int     a;
        struct SELF_REF2 *b;
        int     c;
    }
```
同样在使用typedef技巧时，警惕以下陷阱：
```c 
    typedef struct {
        int     a;
        SELF_REF3 *b;
        int     c;
    } SELF_REF3;
```
原因是在使用SELF_REF3时，它还没被定义出来。
解决方案时定义一个结构标签来声明b，如下所示：
```c 
    typedef struct SELF_REF_TAG {
        int     a;
        struct SELF_REF_TAG *b;
        int     c;
    } SELF_REF3;
```
## 4.4 不完整的声明
在结构体相互引用时，可以使用不完整声明要为结构体标识“占个坑”,从而避免先有鸡还是先有蛋的难题。
```c
    struct B;

    struct A {
        struct B    *partner;
        /* other declaration */
    };

    struct B {
        struct A    *partner;
        /* other declaration */
    };
```

## 4.5 结构体的初始化
结构体的初始化类似与数组的初始化，综合使用花括号，逗号可以为复杂结构的结构完成初始化工作。
```c 
    struct INIT_EX {
        int     a;
        short   b[10];
        Simple  c;      //Simple has been defined above, 
                        //including a int, a char and a float
    } x = {
        10,
        {1,2,3,4,5},
        {25, 'x', 1.9}
    };
```

<hr/>
<br/>
<br/>


# 五. 字符串操作
## 5.1 相关函数
```c 
    
    size_t  strlen( char const *string);  
    //返回字符串长度。
    //strlen（）用来计算指定的字符串 s 的长度，不包括结束字符“\0”。返回字符串 s 的字符数。 

    char    *strcpy(char *dst, char const *src);  
    //拷贝字符串。
    //strcpy（）会将参数 src 字符串拷贝至参数 dst 所指的地址。返回参数 dst 的字符串起始地址

    char    *strcat(char *dst, char const *src);  
    //连接两字符串。
    //strcat（）会将参数 src 字符串拷贝到参数 dst 所指的字符串尾。第一个参数 dst 要有足够的空间来容纳要拷贝的字符串。返回参数 dst 的字符串起始地址

    int     strcmp(char const *s1, char const *s2);  
    //比较字符串。
    //strcmp（）用来比较参数 s1 和 s2 字符串。字符串大小的比较是以 ASCII 码表上的顺序来决定，此顺序亦为字符的值。strcmp（）首先将 s1 第一个字符值减去 s2 第一个字符值，若差值为 0 则再继续比较下个字符，若差值不为 0 则将差值返回。例如字符串“Ac”和“ba”比较则会返回字符“A” （65）和‘b’ （98）的差值（－33）。若参数 s1 和 s2 字符串相同则返回 0。s1 若大于 s2 则返回大于 0 的值。s1 若小于 s2 则返回小于 0 的值。

    char    *strncpy(char *dst, char const *src, size_t len);  
    //拷贝字符串。
    //strncpy（）会将参数 src 字符串拷贝前 len 个字符至参数 dst 所指的地址。返回值 返回参数 dest 的字符串起始地址。

    char    *strncat(char *dst, char const *src, size_t len);  
    //连接两字符串。
    //strncat（）会将参数 src 字符串拷贝 len 个字符到参数 dst 所指的字符串尾。第一个参数 dst 要有足够的空间来容纳要拷贝的字符串。返回值 返回参数 dest 的字符串起始地址。

    int     strncmp(char *s1, char const *s2, size_t n); 
    //比较字符串。
    //strncmp()用来比较参数 s1 和 s2 字符串的前 n 个字符。strncmp()首先将s1 第一个字符值减去s2 第一个字符值，若差值为0 则再继续比较下个字符，直到字符结束标志'\0'，若差值不为0，则将差值返回。例如串"Ac"和"ba"比较则会返回字符"A"(65)和'b'(98)的差值(-33)。注意：要比较的字符包括字符串结束标志'\0'，而且一旦遇到'\0'就结束比较，无论n是多少，不再继续比较后边的字符。返回值 若s1与s2的前n个字符相同，则返回0；若s1大于s2，则返回大于0的值；若s1 若小于s2，则返回小于0的值。

    char    *strchr(char const *str, int ch);  
    //查找字符串中第一个出现的指定字符。
    //strchr（）用来找出参数 str 字符串中第一个出现的参数 ch 地址，然后将该字符出现的地址返回。如果找到指定的字符则返回该字符所在地址，否则返回 0。

    char    *strrchr(char const *str, int ch);  
    //查找字符串中最后出现的指定字符。
    //strrchr（）用来找出参数 str 字符串中最后一个出现的参数 ch 地址，然后将该字符出现的地址返回。返回值 如果找到指定的字符则返回该字符所在地址，否则返回 0。

    char    *strpbrk(char const *str, char const *group);  
    //查找字符串中第一个出现的指定字符。
    //strpbrk（）用来找出参数 str 字符串中最先出现存在参数 group 字符串中的任意字符。返回值 如果找到指定的字符则返回该字符所在地址，否则返回 0。

    char    *strstr(char const *s1, char const *s2); 
    //在一字符串中查找指定的字符串。
    //strstr（）会从字符串 s1 中搜寻字符串 s2 ，并将第一次出现的地址返回。返回值 返回指定字符串第一次出现的地址，否则返回 0。

    size_t  strspn(char const *str, char const *group);  
    //返回字符串中连续含指定字符串内容的字符数。
    //strspn（）从参数 str 字符串的开头计算连续的字符，而这些字符都完全是 group 所指字符串中的字符。简单的说，若 strspn（）返回的数值为 n，则代表字符串 str 开头连续有 n 个字符都是属于字符串 group 内的字符。返回值 返回字符串 str 开头连续包含字符串 gyoup 内的字符数目。

    size_t  strcspn(char const *str, char const *group);  
    //返回字符串中连续不含指定字符串内容的字符数。
    //strcspn（）从参数 str 字符串的开头计算连续的字符，而这些字符都完全不在参数 group 所指的字符串中。简单地说，若 strcspn（）返回的数值为 n，则代表字符串 str 开头连续有 n 个字符都不含字符串group 内的字符。返回字符串 str 开头连续不含字符串 group 内的字符数目
    
    
    int     iscntrl(int ch);  //测试字符是否为ASCII 码的控制字符
    int     isspace(int ch);  //测试字符是否为空格字符
    int     isdigit(int ch);  //测试字符是否为阿拉伯数字
    int     isxdigit(int ch);  //测试字符是否为16进制数字
    int     islower(int ch);  //测试字符是否为小写字母
    int     isupper(int ch);  //测试字符是否为大写英文字母
    int     isalpha(int ch);  //测试字符是否为英文字母
    int     isalnum(int ch);  //测试字符是否为英文或数字
    int     ispunct(int ch);  //测试字符是否为标点符号或特殊符号
    int     isgraph(int ch);  //测试字符是否为可打印字符
    int     isprint(int ch);  //判断字符是否为可打印字符（含空格）

    int     tolower(int ch);  //把字母字符转换成小写
    int     toupper(int ch);  //把字母字符转换成大写


    void    *memcpy(void *dst, void const *src, size_t length);  
    //拷贝内存内容。
    //memcpy（）用来拷贝 src 所指的内存内容前 length 个字节到 dst 所指的内存地址上。与 strcpy（）不同的是，memcpy（）会完整的复制 length个字节，不会因为遇到字符串结束‘\0‘而结束。返回指向 dst 的指针。
    
    void    *memmove(void *dst, void const *src, size_t length);  
    //拷贝内存内容。
    //memmove（）与 memcpy（）一样都是用来拷贝 src 所指的内存内容前 length 个字节到 dst 所指的地址上。不同的是，当 src 和 dst 所指的内存区域重叠时，memmove（）仍然可以正确的处理，不过执行效率上会比使用 memcpy（）略慢些。返回指向 dst 的指针。

    void    *memcmp(void const *a, void const *b, size_t length);  
    //比较内存内容。
    //memcmp（）用来比较 a 和 b 所指的内存区间前 length 个字符。字符串大小的比较是以 ASCII 码表上的顺序来决定，次顺序亦为字符的值。memcmp（）首先将 a 第一个字符值减去 b 第一个字符的值，若差为 0 则再继续比较下个字符，若差值不为 0 则将差值返回。例如，字符串“Ac”和“ba”比较则会返回字符‘A’ （65）和‘b’（98）的差值（－33）。若参数 a 和 b 所指的内存内容都完全相同则返回 0 值。a 若大于b 则返回大于 0 的值。a 若小于 b 则返回小于 0 的值
    void    *memchr(void const *a, int ch, size_t length);  
    //在某一内存范围中查找一特定字符。
    //memchr（）从头开始搜寻 a 所指的内存内容前 length 个字节，直到发现第一个值为 ch 的字节，则返回指向该字节的指针。返回值 如果找到指定的字节则返回该字节的指针，否则返回 0。

    void    *memset(void *a, int ch, size_t length);  
    //将一段内存空间填入某值。
    //memset()会将参数 a 所指的内存区域前 leng 个字节以参数 ch 填入，然后返回指向 a 的指针。在编写程序时，若需要将某一数组作初始化，memset()会相当方便。返回值 返回指向 a 的指针。附加说明参数c虽声明为int， 但必须是unsigned char ，所以范围在0到255之间。
    
    /*(void *）是一个指针类型；空指针。既然是指针，他们它就是一个地址，在内存中，地址就可以用int来表示,参数传递中常常用到（void *）的，尤其多线程。*/
```
<hr/>
<br/>
<br/>

# 六. 动态内存分配
## 6.1 使用动态内存分配
这里有一个例子，他使用malloc分配一块内存
```c 
    int *pi;
    ...
    pi = malloc(100);
    if(pi == NULL){
        printf("Out of memory");
        exit(1);
    }
```
在内存分配成功的情况下，我们获得了一个指向100字节的指针。在整形为4个字节的机器上，这块内存被当作25个整型元素的数组，因为pi是一个指向整型的指针。

为了可移植性，方便在不同的机器上也能获得正确的结果，可以使用下面的技巧
```c 
    pi = malloc(25 * sizeof( int ));
```
通过下面的方式初始化数组元素：
```c 
    int *pi2, i;
    ...
    pi2 = pi;
    for(i = 0; i < 25; i++){
        *pi2++ = 0;
    }
```
也可以通过下标完成相同的工作：
```c
    int i;
    ...
    for(i = 0; i<25; i++){
        pi[i] = 0;
    }
```


# 选择题
1. 下列**不**是可以存储变量的地方是(   )
   - A.普通内存    B.cache    C.运行时堆栈    D.硬件寄存器

2. 下列**不**是可以存储变量相关的关键字的是(   )
   - A.auto    B.register    C.static    D.volatile

阅读下面代码回答3,4,5题
```c
    static int i;       // 声明1
    int func()          // 声明2
    {
        int j;          // 声明3
        extern int k;   // 声明4
        extern int i;   // 声明5
    }
```

3. 请问变量i在声明1和声明5之后的链接属性是(   )
   - A.internal    B.external    C.none  

4. 请问函数func的缺省链接属性是(    )
   - A.internal    B.external    C.none  

5. 请问声明3中的变量j的缺省链接属性是(    )
   - A.internal    B.external    C.none  

6. 请问查找字符串中第一个出现的指定字符的函数是(  )
   - A.strncpy     B.strncmp    C.strchr    D.strrchr

7. 请问查找字符串中最后出现的指定字符的函数是(  )
   - A.strncpy     B.strncmp    C.strchr    D.strrchr

8. 请问在一字符串中查找指定的字符串。的函数是(  )
   - A.strspn     B.strstr    C.strchr    D.strrchr

9. 请问将一段内存空间填入某值的函数是(   )
   - A.memcpy    B.memmove    C.memchr    D.memset

10. 阅读下面代码,思考下列各值含义
```c 
    int array[];
    int *ap = array+2;
```
   - A. ap[0]    B.ap+6    C.ap[-1]   D.*(ap+2)

> BDABC CDBD
